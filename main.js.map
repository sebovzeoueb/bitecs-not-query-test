{
  "version": 3,
  "sources": ["node_modules/bitecs/src/Storage.js", "node_modules/bitecs/src/Util.js", "node_modules/bitecs/src/Serialize.js", "node_modules/bitecs/src/Entity.js", "node_modules/bitecs/src/Query.js", "node_modules/bitecs/src/Component.js", "node_modules/bitecs/src/World.js", "node_modules/bitecs/src/System.js", "node_modules/bitecs/src/index.js", "src/index.js"],
  "sourcesContent": ["export const TYPES_ENUM = {\r\n  i8: 'i8',\r\n  ui8: 'ui8',\r\n  ui8c: 'ui8c',\r\n  i16: 'i16',\r\n  ui16: 'ui16',\r\n  i32: 'i32',\r\n  ui32: 'ui32',\r\n  f32: 'f32',\r\n  f64: 'f64'\r\n}\r\n\r\nexport const TYPES_NAMES = {\r\n  i8: 'Int8',\r\n  ui8: 'Uint8',\r\n  ui8c: 'Uint8Clamped',\r\n  i16: 'Int16',\r\n  ui16: 'Uint16',\r\n  i32: 'Int32',\r\n  ui32: 'Uint32',\r\n  f32: 'Float32',\r\n  f64: 'Float64'\r\n}\r\n\r\nexport const TYPES = {\r\n  i8: Int8Array,\r\n  ui8: Uint8Array,\r\n  ui8c: Uint8ClampedArray,\r\n  i16: Int16Array,\r\n  ui16: Uint16Array,\r\n  i32: Int32Array,\r\n  ui32: Uint32Array,\r\n  f32: Float32Array,\r\n  f64: Float64Array\r\n}\r\n\r\nconst UNSIGNED_MAX = {\r\n  uint8: 2**8,\r\n  uint16: 2**16,\r\n  uint32: 2**32\r\n}\r\n\r\nconst roundToMultiple4 = x => Math.ceil(x / 4) * 4\r\n\r\nexport const $storeRef = Symbol('storeRef')\r\nexport const $storeSize = Symbol('storeSize')\r\nexport const $storeMaps = Symbol('storeMaps')\r\nexport const $storeFlattened = Symbol('storeFlattened')\r\nexport const $storeBase = Symbol('storeBase')\r\nexport const $storeType = Symbol('storeType')\r\n\r\nexport const $storeArrayCounts = Symbol('storeArrayCount')\r\nexport const $storeSubarrays = Symbol('storeSubarrays')\r\nexport const $storeCursor = Symbol('storeCursor')\r\nexport const $subarrayCursors = Symbol('subarrayCursors')\r\nexport const $subarray = Symbol('subarray')\r\nexport const $subarrayFrom = Symbol('subarrayFrom')\r\nexport const $subarrayTo = Symbol('subarrayTo')\r\nexport const $parentArray = Symbol('subStore')\r\nexport const $tagStore = Symbol('tagStore')\r\n\r\nexport const $queryShadow = Symbol('queryShadow')\r\nexport const $serializeShadow = Symbol('serializeShadow')\r\n\r\nexport const $indexType = Symbol('indexType')\r\nexport const $indexBytes = Symbol('indexBytes')\r\n\r\nconst stores = {}\r\n\r\nexport const resize = (ta, size) => {\r\n  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT)\r\n  const newTa = new ta.constructor(newBuffer)\r\n  newTa.set(ta, 0)\r\n  return newTa\r\n}\r\n\r\nexport const createShadow = (store, key) => {\r\n  if (!ArrayBuffer.isView(store)) {\r\n    const shadow = store[$parentArray].slice(0).fill(0)\r\n    for (const k in store[key]) {\r\n      const from = store[key][k][$subarrayFrom]\r\n      const to = store[key][k][$subarrayTo]\r\n      store[key][k] = shadow.subarray(from, to)\r\n    }\r\n  } else {\r\n    store[key] = store.slice(0).fill(0)\r\n  }\r\n}\r\n\r\nconst resizeSubarray = (metadata, store, size) => {\r\n  const cursors = metadata[$subarrayCursors]\r\n  const type = store[$storeType]\r\n  const length = store[0].length\r\n  const indexType =\r\n    length <= UNSIGNED_MAX.uint8\r\n      ? 'ui8'\r\n      : length <= UNSIGNED_MAX.uint16\r\n        ? 'ui16'\r\n        : 'ui32'\r\n        \r\n  const arrayCount = metadata[$storeArrayCounts][type]\r\n  const summedLength = Array(arrayCount).fill(0).reduce((a, p) => a + length, 0)\r\n  \r\n  // for threaded impl\r\n  // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\r\n  // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\r\n  // const buffer = new ArrayBuffer(totalBytes)\r\n\r\n  const array = new TYPES[type](summedLength * size)\r\n\r\n  array.set(metadata[$storeSubarrays][type])\r\n  \r\n  metadata[$storeSubarrays][type] = array\r\n  createShadow(metadata[$storeSubarrays][type], $queryShadow)\r\n  createShadow(metadata[$storeSubarrays][type], $serializeShadow)\r\n  \r\n  array[$indexType] = TYPES_NAMES[indexType]\r\n  array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n\r\n  const start = cursors[type]\r\n  let end = 0\r\n  for (let eid = 0; eid < size; eid++) {\r\n    const from = cursors[type] + (eid * length)\r\n    const to = from + length\r\n\r\n    store[eid] = metadata[$storeSubarrays][type].subarray(from, to)\r\n    \r\n    store[eid][$subarrayFrom] = from\r\n    store[eid][$subarrayTo] = to\r\n    store[eid][$queryShadow] = metadata[$storeSubarrays][type][$queryShadow].subarray(from, to)\r\n    store[eid][$serializeShadow] = metadata[$storeSubarrays][type][$serializeShadow].subarray(from, to)\r\n    store[eid][$subarray] = true\r\n    store[eid][$indexType] = array[$indexType]\r\n    store[eid][$indexBytes] = array[$indexBytes]\r\n    \r\n    end = to\r\n  }\r\n\r\n  cursors[type] = end\r\n\r\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\r\n}\r\n\r\nconst resizeRecursive = (metadata, store, size) => {\r\n  Object.keys(store).forEach(key => {\r\n    const ta = store[key]\r\n    if (Array.isArray(ta)) {\r\n      resizeSubarray(metadata, ta, size)\r\n      store[$storeFlattened].push(ta)\r\n    } else if (ArrayBuffer.isView(ta)) {\r\n      store[key] = resize(ta, size)\r\n      store[$storeFlattened].push(store[key])\r\n      store[key][$queryShadow] = resize(ta[$queryShadow], size)\r\n      store[key][$serializeShadow] = resize(ta[$serializeShadow], size)\r\n    } else if (typeof ta === 'object') {\r\n      resizeRecursive(metadata, store[key], size)\r\n    }\r\n  })\r\n}\r\n\r\nexport const resizeStore = (store, size) => {\r\n  if (store[$tagStore]) return\r\n  store[$storeSize] = size\r\n  store[$storeFlattened].length = 0\r\n  Object.keys(store[$subarrayCursors]).forEach(k => {\r\n    store[$subarrayCursors][k] = 0\r\n  })\r\n  resizeRecursive(store, store, size)\r\n}\r\n\r\nexport const resetStore = store => {\r\n  if (store[$storeFlattened]) {\r\n    store[$storeFlattened].forEach(ta => {\r\n      ta.fill(0)\r\n    })\r\n    Object.keys(store[$storeSubarrays]).forEach(key => {\r\n      store[$storeSubarrays][key].fill(0)\r\n    })\r\n  }\r\n}\r\n\r\nexport const resetStoreFor = (store, eid) => {\r\n  if (store[$storeFlattened]) {\r\n    store[$storeFlattened].forEach(ta => {\r\n      if (ArrayBuffer.isView(ta)) ta[eid] = 0\r\n      else ta[eid].fill(0)\r\n    })\r\n  }\r\n}\r\n\r\nconst createTypeStore = (type, length) => {\r\n  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT\r\n  const buffer = new ArrayBuffer(totalBytes)\r\n  return new TYPES[type](buffer)\r\n}\r\n\r\nexport const parentArray = store => store[$parentArray]\r\n\r\nconst createArrayStore = (metadata, type, length) => {\r\n  const size = metadata[$storeSize]\r\n  const store = Array(size).fill(0)\r\n  store[$storeType] = type\r\n\r\n  const cursors = metadata[$subarrayCursors]\r\n  const indexType =\r\n    length < UNSIGNED_MAX.uint8\r\n      ? 'ui8'\r\n      : length < UNSIGNED_MAX.uint16\r\n        ? 'ui16'\r\n        : 'ui32'\r\n\r\n  if (!length) throw new Error('bitECS - Must define component array length')\r\n  if (!TYPES[type]) throw new Error(`bitECS - Invalid component array property type ${type}`)\r\n\r\n  // create buffer for type if it does not already exist\r\n  if (!metadata[$storeSubarrays][type]) {\r\n    const arrayCount = metadata[$storeArrayCounts][type]\r\n    const summedLength = Array(arrayCount).fill(0).reduce((a, p) => a + length, 0)\r\n    \r\n    // for threaded impl\r\n    // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\r\n    // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\r\n    // const buffer = new ArrayBuffer(totalBytes)\r\n\r\n    const array = new TYPES[type](summedLength * size)\r\n\r\n    metadata[$storeSubarrays][type] = array\r\n    createShadow(metadata[$storeSubarrays][type], $queryShadow)\r\n    createShadow(metadata[$storeSubarrays][type], $serializeShadow)\r\n    \r\n    array[$indexType] = TYPES_NAMES[indexType]\r\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n  }\r\n\r\n  // pre-generate subarrays for each eid\r\n  const start = cursors[type]\r\n  let end = 0\r\n  for (let eid = 0; eid < size; eid++) {\r\n    const from = cursors[type] + (eid * length)\r\n    const to = from + length\r\n\r\n    store[eid] = metadata[$storeSubarrays][type].subarray(from, to)\r\n    \r\n    store[eid][$subarrayFrom] = from\r\n    store[eid][$subarrayTo] = to\r\n    store[eid][$queryShadow] = metadata[$storeSubarrays][type][$queryShadow].subarray(from, to)\r\n    store[eid][$serializeShadow] = metadata[$storeSubarrays][type][$serializeShadow].subarray(from, to)\r\n    store[eid][$subarray] = true\r\n    store[eid][$indexType] = TYPES_NAMES[indexType]\r\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n    \r\n    end = to\r\n  }\r\n\r\n  cursors[type] = end\r\n\r\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\r\n\r\n  return store\r\n}\r\n\r\nconst isArrayType = x => Array.isArray(x) && typeof x[0] === 'string' && typeof x[1] === 'number'\r\n\r\nexport const createStore = (schema, size) => {\r\n  const $store = Symbol('store')\r\n\r\n  if (!schema || !Object.keys(schema).length) {\r\n    // tag component\r\n    stores[$store] = {\r\n      [$storeSize]: size,\r\n      [$tagStore]: true,\r\n      [$storeBase]: () => stores[$store]\r\n    }\r\n    return stores[$store]\r\n  }\r\n\r\n  schema = JSON.parse(JSON.stringify(schema))\r\n\r\n  const arrayCounts = {}\r\n  const collectArrayCounts = s => {\r\n    const keys = Object.keys(s)\r\n    for (const k of keys) {\r\n      if (isArrayType(s[k])) {\r\n        if (!arrayCounts[s[k][0]]) arrayCounts[s[k][0]] = 0\r\n        arrayCounts[s[k][0]]++\r\n      } else if (s[k] instanceof Object) {\r\n        collectArrayCounts(s[k])\r\n      }\r\n    }\r\n  }\r\n  collectArrayCounts(schema)\r\n\r\n  const metadata = {\r\n    [$storeSize]: size,\r\n    [$storeMaps]: {},\r\n    [$storeSubarrays]: {},\r\n    [$storeRef]: $store,\r\n    [$storeCursor]: 0,\r\n    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {}),\r\n    [$storeFlattened]: [],\r\n    [$storeArrayCounts]: arrayCounts\r\n  }\r\n\r\n  if (schema instanceof Object && Object.keys(schema).length) {\r\n\r\n    const recursiveTransform = (a, k) => {\r\n\r\n      if (typeof a[k] === 'string') {\r\n\r\n        a[k] = createTypeStore(a[k], size)\r\n        createShadow(a[k], $queryShadow)\r\n        createShadow(a[k], $serializeShadow)\r\n        a[k][$storeBase] = () => stores[$store]\r\n        metadata[$storeFlattened].push(a[k])\r\n\r\n      } else if (isArrayType(a[k])) {\r\n        \r\n        const [type, length] = a[k]\r\n        a[k] = createArrayStore(metadata, type, length)\r\n        a[k][$storeBase] = () => stores[$store]\r\n        metadata[$storeFlattened].push(a[k])\r\n        // Object.seal(a[k])\r\n\r\n      } else if (a[k] instanceof Object) {\r\n        \r\n        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k])\r\n        // Object.seal(a[k])\r\n        \r\n      }\r\n\r\n      return a\r\n    }\r\n\r\n    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata)\r\n    stores[$store][$storeBase] = () => stores[$store]\r\n\r\n    // Object.seal(stores[$store])\r\n\r\n    return stores[$store]\r\n\r\n  }\r\n}\r\n\r\nexport const free = (store) => {\r\n  delete stores[store[$storeRef]]\r\n}", "export const Uint32SparseSet = (length) => {\r\n  const dense = new Uint32Array(length)\r\n  const sparse = new Uint32Array(length)\r\n\r\n  let cursor = 0\r\n  dense.count = () => cursor + 1\r\n\r\n  const has = val => dense[sparse[val]] === val\r\n\r\n  const add = val => {\r\n    if (has(val)) return\r\n    sparse[val] = cursor\r\n    dense[cursor] = val\r\n\r\n    cursor++\r\n  }\r\n\r\n  const remove = val => {\r\n    if (!has(val)) return\r\n    const index = sparse[val]\r\n    const swapped = dense[cursor]\r\n    if (swapped !== val) {\r\n      dense[index] = swapped\r\n      sparse[swapped] = index\r\n    }\r\n\r\n    cursor--\r\n  }\r\n\r\n  return {\r\n    add,\r\n    remove,\r\n    has,\r\n    sparse,\r\n    dense,\r\n  }\r\n}\r\n\r\nexport const SparseSet = () => {\r\n  const dense = []\r\n  const sparse = []\r\n\r\n  // dense.count = () => dense.length\r\n\r\n  const has = val => dense[sparse[val]] === val\r\n\r\n  const add = val => {\r\n    if (has(val)) return\r\n    sparse[val] = dense.push(val) - 1\r\n  }\r\n\r\n  const remove = val => {\r\n    if (!has(val)) return\r\n    const index = sparse[val]\r\n    const swapped = dense.pop()\r\n    if (swapped !== val) {\r\n      dense[index] = swapped\r\n      sparse[swapped] = index\r\n    }\r\n  }\r\n\r\n  return {\r\n    add,\r\n    remove,\r\n    has,\r\n    sparse,\r\n    dense,\r\n  }\r\n}", "import { $indexBytes, $indexType, $serializeShadow, $storeBase, $storeFlattened, $tagStore, createShadow } from \"./Storage.js\"\r\nimport { $componentMap, addComponent, hasComponent } from \"./Component.js\"\r\nimport { $entityArray, $entitySparseSet, addEntity, eidToWorld } from \"./Entity.js\"\r\nimport { $localEntities } from \"./World.js\"\r\n\r\nexport const DESERIALIZE_MODE = {\r\n  REPLACE: 0,\r\n  APPEND: 1,\r\n  MAP: 2\r\n}\r\n\r\nlet resized = false\r\n\r\nexport const setSerializationResized = v => { resized = v }\r\n\r\nconst canonicalize = (target) => {\r\n  let componentProps = []\r\n  let changedProps = new Map()\r\n  if (Array.isArray(target)) {\r\n    componentProps = target\r\n      .map(p => {\r\n        if (!p) throw new Error('bitECS - Cannot serializer undefined component')\r\n        if (typeof p === 'function' && p.name === 'QueryChanged') {\r\n          p()[$storeFlattened].forEach(prop => {\r\n            const $ = Symbol()\r\n            createShadow(prop, $)\r\n            changedProps.set(prop, $)\r\n          })\r\n          return p()[$storeFlattened]\r\n        }\r\n        if (Object.getOwnPropertySymbols(p).includes($storeFlattened)) {\r\n          return p[$storeFlattened]\r\n        }\r\n        if (Object.getOwnPropertySymbols(p).includes($storeBase)) {\r\n          return p\r\n        }\r\n      })\r\n      .reduce((a,v) => a.concat(v), [])\r\n  }\r\n  return [componentProps, changedProps]\r\n}\r\n\r\n/**\r\n * Defines a new serializer which targets the given components to serialize the data of when called on a world or array of EIDs.\r\n *\r\n * @param {object|array} target\r\n * @param {number} [maxBytes=20000000]\r\n * @returns {ArrayBuffer}\r\n */\r\nexport const defineSerializer = (target, maxBytes = 20000000) => {\r\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\r\n\r\n  let [componentProps, changedProps] = canonicalize(target)\r\n\r\n  // TODO: calculate max bytes based on target & recalc upon resize\r\n\r\n  const buffer = new ArrayBuffer(maxBytes)\r\n  const view = new DataView(buffer)\r\n\r\n  return (ents) => {\r\n\r\n    if (resized) {\r\n      [componentProps, changedProps] = canonicalize(target)\r\n      resized = false\r\n    }\r\n\r\n    if (isWorld) {\r\n      componentProps = []\r\n      target[$componentMap].forEach((c, component) => {\r\n        if (component[$storeFlattened])\r\n          componentProps.push(...component[$storeFlattened])\r\n        else componentProps.push(component)\r\n      })\r\n    }\r\n    \r\n    let world\r\n    if (Object.getOwnPropertySymbols(ents).includes($componentMap)) {\r\n      world = ents\r\n      ents = ents[$entityArray]\r\n    } else {\r\n      world = eidToWorld.get(ents[0])\r\n    }\r\n\r\n    if (!ents.length) return\r\n\r\n    let where = 0\r\n\r\n    // iterate over component props\r\n    for (let pid = 0; pid < componentProps.length; pid++) {\r\n      const prop = componentProps[pid]\r\n      const diff = changedProps.get(prop)\r\n      \r\n      // write pid\r\n      view.setUint8(where, pid)\r\n      where += 1\r\n\r\n      // save space for entity count\r\n      const countWhere = where\r\n      where += 4\r\n      \r\n      let count = 0\r\n      // write eid,val\r\n      for (let i = 0; i < ents.length; i++) {\r\n        const eid = ents[i]\r\n\r\n        // skip if entity doesn't have this component\r\n        if (!hasComponent(world, prop[$storeBase](), eid)) {\r\n          continue\r\n        }\r\n\r\n        // skip if diffing and no change\r\n        // TODO: optimize array diff\r\n        if (diff) {\r\n          if (ArrayBuffer.isView(prop[eid])) {\r\n            let dirty = false\r\n            for (let i = 0; i < prop[eid].length; i++) {\r\n              if(prop[eid][i] !== prop[eid][$serializeShadow][i]) {\r\n                dirty = true\r\n                break\r\n              }\r\n            }\r\n            if (dirty) continue\r\n          } else if (prop[eid] === prop[diff][eid]) continue\r\n        }\r\n\r\n        count++\r\n\r\n        // write eid\r\n        view.setUint32(where, eid)\r\n        where += 4\r\n\r\n        if (prop[$tagStore]) {\r\n          continue\r\n        }\r\n\r\n        // if property is an array\r\n        if (ArrayBuffer.isView(prop[eid])) {\r\n          const type = prop[eid].constructor.name.replace('Array', '')\r\n          const indexType = prop[eid][$indexType]\r\n          const indexBytes = prop[eid][$indexBytes]\r\n\r\n          // add space for count of dirty array elements\r\n          const countWhere2 = where\r\n          where += 1\r\n\r\n          let count2 = 0\r\n\r\n          // write index,value\r\n          for (let i = 0; i < prop[eid].length; i++) {\r\n            const value = prop[eid][i]\r\n\r\n            if (diff && prop[eid][i] === prop[eid][$serializeShadow][i]) {\r\n              continue\r\n            }\r\n\r\n            // write array index\r\n            view[`set${indexType}`](where, i)\r\n            where += indexBytes\r\n\r\n            // write value at that index\r\n            view[`set${type}`](where, value)\r\n            where += prop[eid].BYTES_PER_ELEMENT\r\n            count2++\r\n          }\r\n\r\n          // write total element count\r\n          view[`set${indexType}`](countWhere2, count2)\r\n\r\n        } else {\r\n          // regular property values\r\n          const type = prop.constructor.name.replace('Array', '')\r\n          // set value next [type] bytes\r\n          view[`set${type}`](where, prop[eid])\r\n          where += prop.BYTES_PER_ELEMENT\r\n\r\n          // sync shadow state\r\n          prop[$serializeShadow][eid] = prop[eid]\r\n        }\r\n      }\r\n\r\n      view.setUint32(countWhere, count)\r\n    }\r\n    return buffer.slice(0, where)\r\n  }\r\n}\r\n\r\nconst newEntities = new Map()\r\n\r\n/**\r\n * Defines a new deserializer which targets the given components to deserialize onto a given world.\r\n *\r\n * @param {object|array} target\r\n */\r\nexport const defineDeserializer = (target) => {\r\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\r\n  let [componentProps] = canonicalize(target)\r\n\r\n\r\n  return (world, packet, mode=0) => {\r\n\r\n    newEntities.clear()\r\n    \r\n    if (resized) {\r\n      [componentProps] = canonicalize(target)\r\n      resized = false\r\n    }\r\n\r\n    if (isWorld) {\r\n      componentProps = []\r\n      target[$componentMap].forEach((c, component) => {\r\n        if (component[$storeFlattened])\r\n          componentProps.push(...component[$storeFlattened])\r\n        else componentProps.push(component)\r\n      })\r\n    }\r\n\r\n    const localEntities = world[$localEntities]\r\n\r\n    const view = new DataView(packet)\r\n    let where = 0\r\n\r\n    while (where < packet.byteLength) {\r\n\r\n      // pid\r\n      const pid = view.getUint8(where)\r\n      where += 1\r\n\r\n      // entity count\r\n      const entityCount = view.getUint32(where)\r\n      where += 4\r\n\r\n      // component property\r\n      const prop = componentProps[pid]\r\n\r\n      // Get the entities and set their prop values\r\n      for (let i = 0; i < entityCount; i++) {\r\n        let eid = view.getUint32(where)\r\n        where += 4\r\n\r\n        if (mode === DESERIALIZE_MODE.MAP) {\r\n\r\n          if (localEntities.has(eid)) {\r\n            eid = localEntities.get(eid)\r\n          } else if (newEntities.has(eid)) {\r\n            eid = newEntities.get(eid)\r\n          } else {\r\n            const newEid = addEntity(world)\r\n            localEntities.set(eid, newEid)\r\n            newEntities.set(eid, newEid)\r\n            eid = newEid\r\n          }\r\n        }\r\n\r\n        if (mode === DESERIALIZE_MODE.APPEND ||  \r\n          mode === DESERIALIZE_MODE.REPLACE && !world[$entitySparseSet].has(eid)\r\n        ) {\r\n          const newEid = newEntities.get(eid) || addEntity(world)\r\n          newEntities.set(eid, newEid)\r\n          eid = newEid\r\n        }\r\n\r\n        const component = prop[$storeBase]()\r\n        if (!hasComponent(world, component, eid)) {\r\n          addComponent(world, component, eid)\r\n        }\r\n\r\n        if (component[$tagStore]) {\r\n          continue\r\n        }\r\n        \r\n        if (ArrayBuffer.isView(prop[eid])) {\r\n          const array = prop[eid]\r\n          const count = view[`get${array[$indexType]}`](where)\r\n          where += array[$indexBytes]\r\n\r\n          // iterate over count\r\n          for (let i = 0; i < count; i++) {\r\n            const index = view[`get${array[$indexType]}`](where)\r\n            where += array[$indexBytes]\r\n\r\n            const value = view[`get${array.constructor.name.replace('Array', '')}`](where)\r\n            where += array.BYTES_PER_ELEMENT\r\n\r\n            prop[eid][index] = value\r\n          }\r\n        } else {\r\n          const value = view[`get${prop.constructor.name.replace('Array', '')}`](where)\r\n          where += prop.BYTES_PER_ELEMENT\r\n\r\n          prop[eid] = value\r\n        }\r\n      }\r\n    }\r\n  }\r\n}", "import { resizeComponents } from './Component.js'\r\nimport { $notQueries, $queries, queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query.js'\r\nimport { resizeWorlds } from './World.js'\r\nimport { setSerializationResized } from './Serialize.js'\r\n\r\nexport const $entityMasks = Symbol('entityMasks')\r\nexport const $entityComponents = Symbol('entityMasks')\r\nexport const $entitySparseSet = Symbol('entitySparseSet')\r\nexport const $entityArray = Symbol('entityArray')\r\nexport const $entityIndices = Symbol('entityIndices')\r\nexport const $removedEntities = Symbol('removedEntities')\r\n\r\nlet defaultSize = 100000\r\n\r\n// need a global EID cursor which all worlds and all components know about\r\n// so that world entities can posess entire rows spanning all component tables\r\nlet globalEntityCursor = 0\r\nlet globalSize = defaultSize\r\nlet resizeThreshold = () => globalSize - (globalSize / 5)\r\n\r\nexport const getGlobalSize = () => globalSize\r\n\r\n// removed eids should also be global to prevent memory leaks\r\nconst removed = []\r\n\r\nexport const resetGlobals = () => {\r\n  globalSize = defaultSize\r\n  globalEntityCursor = 0\r\n  removed.length = 0\r\n}\r\n\r\nexport const getDefaultSize = () => defaultSize\r\n\r\n/**\r\n * Sets the default maximum number of entities for worlds and component stores.\r\n *\r\n * @param {number} size\r\n */\r\nexport const setDefaultSize = size => { \r\n  defaultSize = size\r\n  resetGlobals()\r\n}\r\n\r\nexport const getEntityCursor = () => globalEntityCursor\r\nexport const getRemovedEntities = () => removed\r\n\r\nexport const eidToWorld = new Map()\r\n\r\n/**\r\n * Adds a new entity to the specified world.\r\n *\r\n * @param {World} world\r\n * @returns {number} eid\r\n */\r\nexport const addEntity = (world) => {\r\n  \r\n  const eid = removed.length > 0 ? removed.shift() : globalEntityCursor++\r\n  world[$entitySparseSet].add(eid)\r\n  eidToWorld.set(eid, world)\r\n\r\n  // if data stores are 80% full\r\n  if (globalEntityCursor >= resizeThreshold()) {\r\n    // grow by half the original size rounded up to a multiple of 4\r\n    const size = globalSize\r\n    const amount = Math.ceil((size/2) / 4) * 4\r\n    const newSize = size + amount\r\n    globalSize = newSize\r\n    resizeWorlds(newSize)\r\n    resizeComponents(newSize)\r\n    setSerializationResized(true)\r\n    console.info(`\uD83D\uDC7E bitECS - resizing all worlds from ${size} to ${size+amount}`)\r\n  }\r\n\r\n  world[$notQueries].forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryAddEntity(q, eid)\r\n  })\r\n\r\n  world[$entityComponents].set(eid, new Set())\r\n\r\n  return eid\r\n}\r\n\r\n/**\r\n * Removes an existing entity from the specified world.\r\n *\r\n * @param {World} world\r\n * @param {number} eid\r\n */\r\nexport const removeEntity = (world, eid) => {\r\n  // Check if entity is already removed\r\n  if (!world[$entitySparseSet].has(eid)) return\r\n\r\n  // Remove entity from all queries\r\n  // TODO: archetype graph\r\n  world[$queries].forEach(q => {\r\n    queryRemoveEntity(world, q, eid)\r\n  })\r\n\r\n  // Free the entity\r\n  removed.push(eid)\r\n\r\n  // remove all eid state from world\r\n  world[$entitySparseSet].remove(eid)\r\n  world[$entityComponents].delete(eid)\r\n\r\n  // Clear entity bitmasks\r\n  for (let i = 0; i < world[$entityMasks].length; i++) world[$entityMasks][i][eid] = 0\r\n}\r\n\r\n/**\r\n *  Returns an array of components that an entity possesses.\r\n *\r\n * @param {*} world\r\n * @param {*} eid\r\n */\r\nexport const getEntityComponents = (world, eid) => Array.from(world[$entityComponents].get(eid))", "import { SparseSet } from './Util.js'\r\nimport { $queryShadow, $storeFlattened, $tagStore, createShadow } from './Storage.js'\r\nimport { $componentMap, registerComponent } from './Component.js'\r\nimport { $entityMasks, $entityArray, getEntityCursor, $entitySparseSet } from './Entity.js'\r\n\r\nexport function Not(c) { return function QueryNot() { return c } }\r\nexport function Or(c) { return function QueryOr() { return c } }\r\nexport function Changed(c) { return function QueryChanged() { return c } }\r\n\r\nexport const $queries = Symbol('queries')\r\nexport const $notQueries = Symbol('notQueries')\r\nexport const $queryMap = Symbol('queryMap')\r\nexport const $dirtyQueries = Symbol('$dirtyQueries')\r\nexport const $queryComponents = Symbol('queryComponents')\r\nexport const $enterQuery = Symbol('enterQuery')\r\nexport const $exitQuery = Symbol('exitQuery')\r\n\r\n/**\r\n * Given an existing query, returns a new function which returns entities who have been added to the given query since the last call of the function.\r\n *\r\n * @param {function} query\r\n * @returns {function} enteredQuery\r\n */\r\nexport const enterQuery = query => world => {\r\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n  const q = world[$queryMap].get(query)\r\n  return q.entered.splice(0)\r\n}\r\n\r\n/**\r\n * Given an existing query, returns a new function which returns entities who have been removed from the given query since the last call of the function.\r\n *\r\n * @param {function} query\r\n * @returns {function} enteredQuery\r\n */\r\nexport const exitQuery = query => world => {\r\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n  const q = world[$queryMap].get(query)\r\n  return q.exited.splice(0)\r\n}\r\n\r\nexport const registerQuery = (world, query) => {\r\n\r\n  const components = []\r\n  const notComponents = []\r\n  const changedComponents = []\r\n\r\n  query[$queryComponents].forEach(c => {\r\n    if (typeof c === 'function') {\r\n      const comp = c()\r\n      if (!world[$componentMap].has(comp)) registerComponent(world, comp)\r\n      if (c.name === 'QueryNot') {\r\n        notComponents.push(comp)\r\n      }\r\n      if (c.name === 'QueryChanged') {\r\n        changedComponents.push(comp)\r\n        components.push(comp)\r\n      }\r\n    } else {\r\n      if (!world[$componentMap].has(c)) registerComponent(world, c)\r\n      components.push(c)\r\n    }\r\n  })\r\n\r\n\r\n  const mapComponents = c => world[$componentMap].get(c)\r\n\r\n  const allComponents = components.concat(notComponents).map(mapComponents)\r\n\r\n  // const sparseSet = Uint32SparseSet(getGlobalSize())\r\n  const sparseSet = SparseSet()\r\n\r\n  const archetypes = []\r\n  const changed = []\r\n  const toRemove = []\r\n  const entered = []\r\n  const exited = []\r\n\r\n  const generations = allComponents\r\n    .map(c => c.generationId)\r\n    .reduce((a,v) => {\r\n      if (a.includes(v)) return a\r\n      a.push(v)\r\n      return a\r\n    }, [])\r\n\r\n  const reduceBitflags = (a,c) => {\r\n    if (!a[c.generationId]) a[c.generationId] = 0\r\n    a[c.generationId] |= c.bitflag\r\n    return a\r\n  }\r\n  const masks = components\r\n    .map(mapComponents)\r\n    .reduce(reduceBitflags, {})\r\n\r\n  const notMasks = notComponents\r\n    .map(mapComponents)\r\n    .reduce((a,c) => {\r\n      if (!a[c.generationId]) {\r\n        a[c.generationId] = 0\r\n      }\r\n      a[c.generationId] |= c.bitflag\r\n      return a\r\n    }, {})\r\n\r\n  // const orMasks = orComponents\r\n  //   .map(mapComponents)\r\n  //   .reduce(reduceBitmasks, {})\r\n\r\n  const hasMasks = allComponents\r\n    .reduce(reduceBitflags, {})\r\n\r\n  const flatProps = components\r\n    .filter(c => !c[$tagStore])\r\n    .map(c => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c])\r\n    .reduce((a,v) => a.concat(v), [])\r\n\r\n  const shadows = flatProps.map(prop => {\r\n      const $ = Symbol()\r\n      createShadow(prop, $)\r\n      return prop[$]\r\n  }, [])\r\n\r\n  const q = Object.assign(sparseSet, {\r\n    archetypes,\r\n    changed,\r\n    components,\r\n    notComponents,\r\n    changedComponents,\r\n    masks,\r\n    notMasks,\r\n    // orMasks,\r\n    hasMasks,\r\n    generations,\r\n    flatProps,\r\n    toRemove,\r\n    entered,\r\n    exited,\r\n    shadows,\r\n  })\r\n\r\n  \r\n  world[$queryMap].set(query, q)\r\n  world[$queries].add(q)\r\n  \r\n  components.map(mapComponents).forEach(c => {\r\n    c.queries.add(q)\r\n  })\r\n  notComponents.map(mapComponents).forEach(c => {\r\n    c.notQueries.add(q)\r\n  })\r\n\r\n  if (notComponents.length) world[$notQueries].add(q)\r\n\r\n  for (let eid = 0; eid < getEntityCursor(); eid++) {\r\n    if (!world[$entitySparseSet].has(eid)) continue\r\n    if (queryCheckEntity(world, q, eid)) {\r\n      queryAddEntity(q, eid)\r\n    }\r\n  }\r\n}\r\n\r\nconst diff = (q, clearDiff) => {\r\n  if (clearDiff) q.changed.length = 0\r\n  const { flatProps, shadows } = q\r\n  for (let i = 0; i < q.dense.length; i++) {\r\n    const eid = q.dense[i]\r\n    let dirty = false\r\n    for (let pid = 0; pid < flatProps.length; pid++) {\r\n      const prop = flatProps[pid]\r\n      const shadow = shadows[pid]\r\n      if (ArrayBuffer.isView(prop[eid])) {\r\n        for (let i = 0; i < prop[eid].length; i++) {\r\n          if (prop[eid][i] !== prop[eid][$queryShadow][i]) {\r\n            dirty = true\r\n            prop[eid][$queryShadow][i] = prop[eid][i]\r\n          }\r\n        }\r\n      } else {\r\n        if (prop[eid] !== shadow[eid]) {\r\n          dirty = true\r\n          shadow[eid] = prop[eid]\r\n        }\r\n      }\r\n    }\r\n    if (dirty) q.changed.push(eid)\r\n  }\r\n  return q.changed\r\n}\r\n\r\n\r\n/**\r\n * Defines a query function which returns a matching set of entities when called on a world.\r\n *\r\n * @param {array} components\r\n * @returns {function} query\r\n */\r\n\r\nexport const defineQuery = (components) => {\r\n  if (components === undefined || components[$componentMap] !== undefined) {\r\n    return world => world ? world[$entityArray] : components[$entityArray]\r\n  }\r\n\r\n  const query = function (world, clearDiff=true) {\r\n    if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n\r\n    const q = world[$queryMap].get(query)\r\n\r\n    queryCommitRemovals(q)\r\n\r\n    if (q.changedComponents.length) return diff(q, clearDiff)\r\n\r\n    return q.dense\r\n  }\r\n  query[$queryComponents] = components\r\n  return query\r\n}\r\n\r\n// TODO: archetype graph\r\nexport const queryCheckEntity = (world, q, eid) => {\r\n  const { masks, notMasks, generations } = q\r\n  // let or = true\r\n  for (let i = 0; i < generations.length; i++) {\r\n    const generationId = generations[i]\r\n    const qMask = masks[generationId]\r\n    const qNotMask = notMasks[generationId]\r\n    // const qOrMask = orMasks[generationId]\r\n    const eMask = world[$entityMasks][generationId][eid]\r\n    \r\n    // if (qOrMask && (eMask & qOrMask) !== qOrMask) {\r\n    //   continue\r\n    // }\r\n    if (qNotMask && (eMask & qNotMask) !== 0) {\r\n      return false\r\n    }\r\n    if (qMask && (eMask & qMask) !== qMask) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nexport const queryCheckComponent = (q, c) => {\r\n  const { generationId, bitflag } = c\r\n  const { hasMasks } = q\r\n  const mask = hasMasks[generationId]\r\n  return (mask & bitflag) === bitflag\r\n}\r\n\r\nexport const queryAddEntity = (q, eid) => {\r\n  if (q.has(eid)) return\r\n  q.add(eid)\r\n  q.entered.push(eid)\r\n}\r\n\r\nconst queryCommitRemovals = (q) => {\r\n  while (q.toRemove.length) {\r\n    q.remove(q.toRemove.pop())\r\n  }\r\n}\r\n\r\nexport const commitRemovals = (world) => {\r\n  world[$dirtyQueries].forEach(queryCommitRemovals)\r\n  world[$dirtyQueries].clear()\r\n}\r\n\r\nexport const queryRemoveEntity = (world, q, eid) => {\r\n  if (!q.has(eid)) return\r\n  q.toRemove.push(eid)\r\n  world[$dirtyQueries].add(q)\r\n  q.exited.push(eid)\r\n}\r\n\r\n\r\n/**\r\n * Resets a Changed-based query, clearing the underlying list of changed entities.\r\n *\r\n * @param {World} world\r\n * @param {function} query\r\n */\r\nexport const resetChangedQuery = (world, query) => {\r\n  const q = world[$queryMap].get(query)\r\n  q.changed.length = 0\r\n}\r\n\r\n/**\r\n * Removes a query from a world.\r\n *\r\n * @param {World} world\r\n * @param {function} query\r\n */\r\nexport const removeQuery = (world, query) => {\r\n  const q = world[$queryMap].get(query)\r\n  world[$queries].delete(q)\r\n  world[$queryMap].delete(query)\r\n}", "import { $storeSize, createStore, resetStoreFor, resizeStore } from './Storage.js'\r\nimport { $queries, queryAddEntity, queryRemoveEntity, queryCheckEntity } from './Query.js'\r\nimport { $bitflag, $size } from './World.js'\r\nimport { $entityMasks, getDefaultSize, eidToWorld, $entityComponents } from './Entity.js'\r\n\r\nexport const $componentMap = Symbol('componentMap')\r\n\r\nexport const components = []\r\n\r\nexport const resizeComponents = (size) => {\r\n  components.forEach(component => resizeStore(component, size))\r\n}\r\n\r\n\r\n/**\r\n * Defines a new component store.\r\n *\r\n * @param {object} schema\r\n * @returns {object}\r\n */\r\nexport const defineComponent = (schema) => {\r\n  const component = createStore(schema, getDefaultSize())\r\n  if (schema && Object.keys(schema).length) components.push(component)\r\n  return component\r\n}\r\n\r\nexport const incrementBitflag = (world) => {\r\n  world[$bitflag] *= 2\r\n  if (world[$bitflag] >= 2**32) {\r\n    world[$bitflag] = 1\r\n    world[$entityMasks].push(new Uint32Array(world[$size]))\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Registers a component with a world.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n */\r\nexport const registerComponent = (world, component) => {\r\n  if (!component) throw new Error(`bitECS - Cannot register null or undefined component`)\r\n\r\n  const queries = new Set()\r\n  const notQueries = new Set()\r\n\r\n  world[$queries].forEach(q => {\r\n    if (q.components.includes(component)) {\r\n      queries.add(q)\r\n    } else if (q.notComponents.includes(component)) {\r\n      notQueries.add(q)\r\n    }\r\n  })\r\n\r\n  world[$componentMap].set(component, { \r\n    generationId: world[$entityMasks].length - 1,\r\n    bitflag: world[$bitflag],\r\n    store: component,\r\n    queries,\r\n    notQueries,\r\n  })\r\n\r\n  if (component[$storeSize] < world[$size]) {\r\n    resizeStore(component, world[$size])\r\n  }\r\n\r\n  incrementBitflag(world)\r\n}\r\n\r\n/**\r\n * Registers multiple components with a world.\r\n *\r\n * @param {World} world\r\n * @param {Component} components\r\n */\r\nexport const registerComponents = (world, components) => {\r\n  components.forEach(c => registerComponent(world, c))\r\n}\r\n\r\n/**\r\n * Checks if an entity has a component.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @returns {boolean}\r\n */\r\nexport const hasComponent = (world, component, eid) => {\r\n  const registeredComponent = world[$componentMap].get(component)\r\n  if (!registeredComponent) return\r\n  const { generationId, bitflag } = registeredComponent\r\n  const mask = world[$entityMasks][generationId][eid]\r\n  return (mask & bitflag) === bitflag\r\n}\r\n\r\n/**\r\n * Adds a component to an entity\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @param {boolean} [reset=false]\r\n */\r\nexport const addComponent = (world, component, eid, reset=false) => {\r\n  if (!Number.isInteger(eid)) {\r\n    component = world\r\n    world = eidToWorld.get(eid)\r\n    reset = eid || reset\r\n  }\r\n  if (!world[$componentMap].has(component)) registerComponent(world, component)\r\n  if (hasComponent(world, component, eid)) return\r\n\r\n  const c = world[$componentMap].get(component)\r\n  const { generationId, bitflag, queries, notQueries } = c\r\n  \r\n  notQueries.forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryRemoveEntity(world, q, eid)\r\n  })\r\n  \r\n  // Add bitflag to entity bitmask\r\n  world[$entityMasks][generationId][eid] |= bitflag\r\n\r\n  // todo: archetype graph\r\n  queries.forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryAddEntity(q, eid)\r\n  })\r\n\r\n  world[$entityComponents].get(eid).add(component)\r\n\r\n  // Zero out each property value\r\n  if (reset) resetStoreFor(component, eid)\r\n}\r\n\r\n/**\r\n * Removes a component from an entity and resets component state unless otherwise specified.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @param {boolean} [reset=true]\r\n */\r\nexport const removeComponent = (world, component, eid, reset=true) => {\r\n  if (!Number.isInteger(eid)) {\r\n    component = world\r\n    world = eidToWorld.get(eid)\r\n    reset = eid || reset\r\n  }\r\n  const c = world[$componentMap].get(component)\r\n  const { generationId, bitflag, queries, notQueries } = c\r\n\r\n  if (!(world[$entityMasks][generationId][eid] & bitflag)) return\r\n\r\n  // todo: archetype graph\r\n  queries.forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryRemoveEntity(world, q, eid)\r\n  })\r\n\r\n  // Remove flag from entity bitmask\r\n  world[$entityMasks][generationId][eid] &= ~bitflag\r\n  \r\n  notQueries.forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryAddEntity(q, eid)\r\n  })\r\n  \r\n  world[$entityComponents].get(eid).delete(component)\r\n\r\n  // Zero out each property value\r\n  if (reset) resetStoreFor(component, eid)\r\n}\r\n", "import { $componentMap } from './Component.js'\r\nimport { $queryMap, $queries, $dirtyQueries, $notQueries } from './Query.js'\r\nimport { $entityArray, $entityComponents, $entityMasks, $entitySparseSet, getGlobalSize, removeEntity } from './Entity.js'\r\nimport { resize } from './Storage.js'\r\nimport { SparseSet } from './Util.js'\r\n\r\nexport const $size = Symbol('size')\r\nexport const $resizeThreshold = Symbol('resizeThreshold')\r\nexport const $bitflag = Symbol('bitflag')\r\nexport const $archetypes = Symbol('archetypes')\r\nexport const $localEntities = Symbol('localEntities')\r\n\r\nexport const worlds = []\r\n\r\nexport const resizeWorlds = (size) => {\r\n  worlds.forEach(world => {\r\n    world[$size] = size\r\n\r\n    for (let i = 0; i < world[$entityMasks].length; i++) {\r\n      const masks = world[$entityMasks][i];\r\n      world[$entityMasks][i] = resize(masks, size)\r\n    }\r\n    \r\n    world[$resizeThreshold] = world[$size] - (world[$size] / 5)\r\n  })\r\n}\r\n\r\n/**\r\n * Creates a new world.\r\n *\r\n * @returns {object}\r\n */\r\nexport const createWorld = () => {\r\n  const world = {}\r\n  resetWorld(world)\r\n  worlds.push(world)\r\n  return world\r\n}\r\n\r\n/**\r\n * Resets a world.\r\n *\r\n * @param {World} world\r\n * @returns {object}\r\n */\r\nexport const resetWorld = (world) => {\r\n  const size = getGlobalSize()\r\n  world[$size] = size\r\n\r\n  if (world[$entityArray]) world[$entityArray].forEach(eid => removeEntity(world, eid))\r\n\r\n  world[$entityMasks] = [new Uint32Array(size)]\r\n  world[$entityComponents] = new Map()\r\n  world[$archetypes] = []\r\n\r\n  world[$entitySparseSet] = SparseSet()\r\n  world[$entityArray] = world[$entitySparseSet].dense\r\n\r\n  world[$bitflag] = 1\r\n\r\n  world[$componentMap] = new Map()\r\n\r\n  world[$queryMap] = new Map()\r\n  world[$queries] = new Set()\r\n  world[$notQueries] = new Set()\r\n  world[$dirtyQueries] = new Set()\r\n\r\n  world[$localEntities] = new Map()\r\n\r\n  return world\r\n}\r\n\r\n/**\r\n * Deletes a world.\r\n *\r\n * @param {World} world\r\n */\r\nexport const deleteWorld = (world) => {\r\n  Object.getOwnPropertySymbols(world).forEach($ => { delete world[$] })\r\n  Object.keys(world).forEach(key => { delete world[key] })\r\n  worlds.splice(worlds.indexOf(world), 1)\r\n}\r\n", "import { commitRemovals } from './Query.js'\r\n\r\n/**\r\n * Defines a new system function.\r\n *\r\n * @param {function} update\r\n * @returns {function}\r\n */\r\nexport const defineSystem = (fn1, fn2) => {\r\n  const update = fn2 !== undefined ? fn2 : fn1\r\n  const create = fn2 !== undefined ? fn1 : undefined\r\n  const init = new Set()\r\n  const system = (world, ...args) => {\r\n    if (create && !init.has(world)) {\r\n      create(world, ...args)\r\n      init.add(world)\r\n    }\r\n    update(world, ...args)\r\n    commitRemovals(world)\r\n    return world\r\n  }\r\n\r\n  Object.defineProperty(system, 'name', {\r\n    value: (update.name || \"AnonymousSystem\") + \"_internal\",\r\n    configurable: true,\r\n  })\r\n\r\n  return system\r\n}", "import { createWorld, resetWorld, deleteWorld } from './World.js'\r\nimport { addEntity, removeEntity, setDefaultSize, getEntityComponents} from './Entity.js'\r\nimport { defineComponent, registerComponent, registerComponents, hasComponent, addComponent, removeComponent } from './Component.js'\r\nimport { defineSystem } from './System.js'\r\nimport { defineQuery, enterQuery, exitQuery, Changed, Not, commitRemovals, resetChangedQuery, removeQuery } from './Query.js'\r\nimport { defineSerializer, defineDeserializer, DESERIALIZE_MODE } from './Serialize.js'\r\nimport { TYPES_ENUM, parentArray } from './Storage.js'\r\n// import { defineProxy } from './Proxy.js'\r\n\r\nexport const pipe = (...fns) => (...args) => {\r\n  const input = Array.isArray(args[0]) ? args[0] : args\r\n  if (!input || input.length === 0) return\r\n  fns = Array.isArray(fns[0]) ? fns[0] : fns\r\n  let tmp = input\r\n  for (let i = 0; i < fns.length; i++) {\r\n    const fn = fns[i]\r\n    if (Array.isArray(tmp)) {\r\n      // tmp = tmp.reduce((a,v) => a.concat(fn(v)),[])\r\n      tmp = fn(...tmp)\r\n    } else {\r\n      tmp = fn(tmp)\r\n    }\r\n  }\r\n  return tmp\r\n}\r\n\r\nexport const Types = TYPES_ENUM\r\n\r\nexport {\r\n\r\n  setDefaultSize,\r\n  createWorld,\r\n  resetWorld,\r\n  deleteWorld,\r\n  addEntity,\r\n  removeEntity,\r\n\r\n  registerComponent,\r\n  registerComponents,\r\n  defineComponent,\r\n  addComponent,\r\n  removeComponent,\r\n  hasComponent,\r\n  getEntityComponents,\r\n\r\n  // defineProxy,\r\n\r\n  defineQuery,\r\n  Changed,\r\n  Not,\r\n  // Or,\r\n  enterQuery,\r\n  exitQuery,\r\n  commitRemovals,\r\n  resetChangedQuery,\r\n  removeQuery,\r\n\r\n  defineSystem,\r\n  \r\n  defineSerializer,\r\n  defineDeserializer,\r\n  DESERIALIZE_MODE,\r\n\r\n  parentArray,\r\n\r\n}\r\n", "import { addComponent, addEntity, commitRemovals, createWorld, defineComponent, defineQuery, defineSystem, hasComponent, Not, pipe, removeComponent } from \"bitecs\"\r\n\r\nconsole.log(\"Testing bitECS queries\")\r\n\r\nconst ComponentA = defineComponent()\r\nconst world = createWorld()\r\nconst eid = addEntity(world)\r\n\r\nconst hasA = defineQuery([ComponentA])\r\nconst doesntHaveA = defineQuery([Not(ComponentA)])\r\n\r\nlet prevHasA\r\nlet prevDoesntA\r\n\r\nconst systemA = defineSystem(world => {\r\n  hasA(world).forEach(eid => {\r\n    removeComponent(world, ComponentA, eid)\r\n    console.log(\"Removed Component A\")\r\n  })\r\n  // commitRemovals(world)\r\n  doesntHaveA(world).forEach(eid => {\r\n    addComponent(world, ComponentA, eid)\r\n    console.log(\"Added Component A\")\r\n  })\r\n  const has = hasA(world).length\r\n  const doesnt = doesntHaveA(world).length\r\n  if (prevHasA !== has || prevDoesntA !== doesnt) {\r\n    console.log(`systemA: ${has} entities have A, ${doesnt} entities don't have A`)\r\n  }\r\n  prevHasA = has\r\n  prevDoesntA = doesnt\r\n})\r\n\r\nlet prevEntHas\r\nlet prevHasB\r\nlet prevDoesntB\r\n\r\nconst systemB = defineSystem(world => {\r\n  const entHas = hasComponent(world, ComponentA, eid)\r\n  if (prevEntHas !== entHas) {\r\n    console.log(`systemB: entity has Component A: ${entHas}`)\r\n  }\r\n  const has = hasA(world).length\r\n  const doesnt = doesntHaveA(world).length\r\n  if (prevHasB !== has || prevDoesntB !== doesnt) {\r\n    console.log(`systemB: ${has} entities have A, ${doesnt} entities don't have A`)\r\n  }\r\n  prevHasB = has\r\n  prevDoesntB = doesnt\r\n  prevEntHas = entHas\r\n})\r\n\r\nconst pipeline = pipe([systemA, systemB])\r\n\r\nlet lastTime = performance.now()\r\nworld.time = { }\r\nconst tick = () => {\r\n  world.time.time = performance.now()\r\n  world.time.delta = world.time.time - lastTime\r\n  lastTime = world.time.time\r\n  pipeline(world)\r\n  requestAnimationFrame(tick)\r\n}\r\ntick()"],
  "mappings": "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",
  "names": []
}
